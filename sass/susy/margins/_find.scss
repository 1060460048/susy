//////////////////////////////
// Find margin
//
// Finds the margin that you are on.
// From Singularity
// Must be using Breakpoint to work properly
//////////////////////////////
@function find-margin($user-margins: false) {
  $length: length($margins);

  @if $user-margins != false {
    @return $user-margins;
  }
  @else if $length > 1 {
    $query-min: breakpoint-get-context('min-width');
    $query-max: breakpoint-get-context('max-width');

    // If we've got a min-width or max-width
    @if $query-min or $query-max {
      // Reverse the margin so we can step through it
      $reverse-margin: ();
      @for $i from 2 through $length {
        $reverse-margin: append($reverse-margin, nth($margins, $i), comma);
      }
      $reverse-margin: reverse($reverse-margin);
      $rg-length: $length - 1;

      // Grab the largest and smallest MQs
      $smallest: nth(nth($margins, 2), 2);
      $largest: nth(nth($reverse-margin, 1), 2);
      $context: $query-min;


      // Figure out the direction of the margins
      // @if not ($mobile-first) {
      //   $context: $query-max;
      // }

      // If it's smallest than the smallest MQ, use the 1st margin
      @if $context < $smallest {
        @return nth($margins, 1);
      }
      // If it's larger than or equal to the largest MQ, use the last margin
      @else if $context >= $largest {
        @return nth(nth($reverse-margin, 1), 1);
      }
      @else {
        // Loop through each MQ. If the MQ is greather than or equal to the the MQ in question, use it!
        @for $j from 1 through $rg-length {
          $query: nth(nth($reverse-margin, $j), 2);
          @if $context >= $query {
            @return nth(nth($reverse-margin, $j), 1);
          }
        }
      }

    }
    @else {
      @return nth($margins, 1);
    }
  }
  @else {
    @return nth($margins, 1);
  }
}
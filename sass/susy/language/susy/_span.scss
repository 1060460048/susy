// Span language parsing
// =====================
//
// Mixins:
// - span()

// Set a spanning element using shorthand syntax
@mixin span(
  $span
) {
  $span: parse-span($span);
  $output: span-math($span...);

  @include float-span-output($output...);
}

// Gallery
@mixin gallery(
  $input,
  $selector: child
) {
  $this-isolate: get-span-setting(isolate, $input, parse);

  @if $this-isolate {
    @include isolate-gallery($input);
  } @else {
    @include nth-gallery($input);
  }
}

// Span Helpers
// ------------

// Parse the span shortcut syntax
@function parse-span(
  $string
) {
  $new-span           : false;
  $new-location       : false;
  $new-context        : false;
  $new-isolate        : false;
  $new-static         : false;
  $new-columns        : false;
  $new-gutters        : false;
  $new-column-width   : false;
  $new-flow           : false;
  $new-gutter-place   : false;

  $i: 1;

  @while $i <= length($string) {
    $value  : nth($string,$i);
    $at     : false;
    $of     : false;

    // keywords
    @if type-of($value) == string {

      // location keywords: first | last | alpha | omega
      @if $value == first or $value == alpha {
        $new-location: 1;
      } @else if $value == last or $value == omega {
        $new-location: last;
      }

      // isolate
      @else if $value == isolate {
        $new-isolate: isolate;
      } @else if $value == float {
        $new-isolate: float;
      }

      // static | fluid
      @else if $value == static {
        $new-static: static;
      } @else if $value == fluid {
        $new-static: fluid;
      }

      // ltr | rtl
      @else if $value == rtl {
        $new-flow: rtl;
      } @else if $value == ltr {
        $new-flow: ltr;
      }

      // after | before
      @else if $value == after {
        $new-gutter-place: after;
      } @else if $value == before {
        $new-gutter-place: before;
      }

      // at
      @else if $value == at {
        $at: true;
      }

      // of
      @else if $value == of {
        $of: true;
      }

    // span
    } @else if not $new-span and type-of($value) == number {
      $new-span: $value;
    }

    // location integer
    @if $at {
      $i: $i + 1;
      $new-location: nth($string, $i);
    }

    // context
    @if $of {
      $i: $i + 1;
      $new-context: compact();

      @while $of and $i <= length($string) {
        $this: nth($string,$i);
        @if type-of($this) != string {
          $new-context: append($new-context, $this);
          $i: $i + 1;
        } @else {
          $of: false;
          $i: $i - 1;
        }
      }
    }

    $i: $i + 1;
  }

  // parse the context
  @if $new-context {
    $new-columns: get-setting(columns, $new-context);
    $new-gutters: get-setting(gutters, $new-context);
    $new-column-width: get-setting(column-width, $new-context);
  }

  // use global values for empty grid settings
  @if not $new-columns {
    $new-columns: $columns;
  }
  @if not $new-gutters {
    $new-gutters: $gutters;
  }
  @if not $new-column-width {
    $new-column-width: $column-width;
  }
  @if not $new-static {
    $new-static: $static;
  }
  @if not $new-isolate {
    $new-isolate: $isolate;
  }
  @if not $new-flow {
    $new-flow: $flow;
  }
  @if not $new-gutter-place {
    $new-gutter-place: $gutter-placement;
  }

  @return $new-span $new-location $new-columns $new-gutters $new-column-width $new-isolate $new-static $new-flow $new-gutter-place;
}

// Return one particular span setting from a list
@function get-span-setting(
  $setting,
  $span,
  $parse: false
) {
  $options  : span location columns gutters column-width isolate static flow gutter-placement;
  $key      : index($options, $setting);
  $value    : false;

  @if $parse {
    $span: parse-span($span);
  }

  @if $key {
    $value: nth($span, $key);
  }

  @return $value;
}

// Get all the span results
@function span-math(
  $span,
  $location,
  $columns          : $columns,
  $gutters          : $gutters,
  $column-width     : $column-width,
  $isolate          : $isolate,
  $static           : $static,
  $flow             : $flow,
  $gutter-place     : $gutter-placement
) {
  $float            : from($flow);
  $width            : $span;

  $column           : null;

  $static           : if($static and $static != fluid, true, false);
  $isolate          : if($isolate and $isolate != float, true, false);

  // calculations
  $width            : get-span-width($span, $location, $columns, $gutters, $column-width, $static);

  // gutter location
  $gutter-location  : get-gutters($columns, $gutters, $column-width, $static, $gutter-place);
  $margin-before    : nth($gutter-location,1);
  $margin-after     : nth($gutter-location,2);
  $padding-before   : null;
  $padding-after    : null;

  // special margin handling
  @if $isolate {
    $margin-before: get-isolation($span, $location, $columns, $gutters, $column-width, $static);
    $margin-after: -100%;
  } @else {
    @if is-last($span, $location, $columns) {
      $float: to($flow);
      $margin-after: null;
    } @else if is-first($location) {
      $margin-before: null;
    }
  }

  @return $width $float $margin-before $margin-after $padding-before $padding-after $flow;
}

// Return gutter width
@function get-gutter-width(
  $columns,
  $gutters,
  $column-width,
  $static
) {
  $context  : column-sum($columns, $gutters);
  $gutter   : null;

  @if $static {
    @if $column-width {
      $gutter: $gutters * $column-width;
    } @else {
      @warn "Please set a $column-width to use for static output.";
    }
  } @else {
    $gutter: percentage($gutters / $context);
  }

  @return $gutter;
}

@function get-gutters(
  $columns,
  $gutters,
  $column-width,
  $static,
  $gutter-place: $gutter-placement
) {
  $gutter   : get-gutter-width($columns, $gutters, $column-width, $static);
  $before   : null;
  $after    : null;

  @if $gutter-place == before {
    $before: $gutter;
  } @else if $gutter-place == after {
    $after: $gutter;
  } @else if $gutter-place == split {
    $before: $gutter / 2;
    $after: $gutter / 2;
  }

  @return $before $after;
}

// Return span width
@function get-span-width(
  $span,
  $location,
  $columns,
  $gutters,
  $column-width,
  $static
) {
  $context  : column-sum($columns, $gutters);
  $width    : null;

  @if unitless($span) {
    $span-sum: get-column-span-sum($span, $location, $columns, $gutters);

    @if $static {
      $width: $span-sum * $column-width;
    } @else {
      $width: percentage($span-sum / $context);
    }
  }

  @return $width;
}

@mixin nth-gallery(
  $input
) {
  $this-input         : parse-span($input);

  $span               : get-span-setting(span, $this-input);
  $this-columns       : get-span-setting(columns, $this-input);
  $context            : column-count($this-columns);
  $line               : floor($context / $span);

  @include span($input);

  @if is-symmetrical($this-columns) {
    @include nth-first('#{$line}n + 1');
    @include nth-last('#{$line}n');
  } @else {
    $location           : 1;
    $this-columns       : get-span-setting(columns, $this-input);
    $this-gutters       : get-span-setting(gutters, $this-input);
    $this-column-width  : get-span-setting(column-width, $this-input);
    $this-static        : get-span-setting(static, $this-input);

    @for $item from 1 through $line {
      $nth: '#{$line}n + #{$item}';
      &:#{format-nth($nth,$selector)} {

        width: span($span, $location, $this-columns, $this-gutters, $this-column-width, $this-static);

        $location: $location + $span;
        @if $location > $context { $location: 1; }
      }
    }
  }

}
